Sequence Diagrams
=======

This library is used to generate syntax diagrams (https://en.wikipedia.org/wiki/Syntax_diagram) from Scala code. 
Features:
* Grammar is defined directly in Scala
* Diagrams are generated as SVG files:
  * Can be styled via CSS
  * Non-terminals can be rendered as links to separate diagrams 
  
Usage
-----

Diagrams are represented by type Expr. You can use its subclasses 
to construct primitives and combine them into larger expressions:
* Symbols
  * `Terminal(value: String)`
  * `NonTerminal(value: String)`
  * `Special(value: String)` - special kind of terminal. For example: textual description, regexp etc.
* Combinators
  * `Repeat(e: Expr)` - at least one e
  * `Optional(e: Expr)` - e or nothing
  * `Choice(es: Seq[Expr])` - selects one of the alternatives
  * `Sequence(es: Seq[Expr])` - joins es in a sequence (concatenation)

Diagrams are generated by the method `SVG.createDiagram`:
```scala
def createDiagram(rhs: Expr, options: Options = Options()): Tag
```

You can specify the following options:
* `maxWidth` - maximal width of the diagram. This is **not** a hard constraint - the generator does its best to fit the diagram but it may fail to do so. It can only split top-level Sequence combinators.
* `cssClass` - css class name used in generated SVG diagram
* `embeddedStyle` - CSS to embed directly in SVG
* `linker: String => String` - method used to convert NonTerminals to HTML links. By default does nothing (_ => "").

Example
-------

The following snippet defines the grammar for the JSON format.
```scala
import org.github.sheliaklyr.ebnf.{Expr, Grammar}
import org.github.sheliaklyr.ebnf.Ebnf._
Grammar(
    "json" -> ref("object").|(ref("array")),
    "digitP" -> Special("[1-9]"),
    "digit" -> Special("[0-9]"),
    "hexDigit" -> Special("[0-9A-Fa-f]"),
    "string" -> {
        val unicode = Special("Any UNICODE char except: \" \\ or control character")
        val escaped = "\\" ~ choice(
          "\"",
          "\\",
          "/",
          "b",
          "f",
          "n",
          "r",
          "t",
          "u" ~ ref("hexDigit").rep(4)
        )
        "\"" ~ (unicode | escaped).* ~ "\""
    },
    "number" -> {
      val beforeDot = "0" | (ref("digitP") ~ ref("digit").*)
      val exp = ("E" | "e") ~ ("-" | "+").? ~ ref("digit").+
      "-".? ~ beforeDot ~ ("." ~ ref("digit").+).? ~ exp.?
    },
    "value" -> choice(
      ref("object"),
      ref("array"),
      ref("string"),
      ref("number"),
      "true",
      "false",
      "null"
    ),
    "pair" -> ref("string") ~ ":" ~ ref("value"),
    "object" -> "{" ~ ref("pair").repSepBy(",") ~ "}",
    "array" -> "[" ~ ref("value").repSepBy(ref("value")) ~ "]"
  )
```

Generated diagrams:

### json
![json](examples/diagrams/json/json.svg)

### object
![Object](examples/diagrams/json/object.svg)

### array
![Array](examples/diagrams/json/array.svg)

### value
![Value](examples/diagrams/json/value.svg)

### pair
![Pair](examples/diagrams/json/pair.svg)

### string
![String](examples/diagrams/json/string.svg)

### number
![Value](examples/diagrams/json/value.svg)

### digitP
![DigitP](examples/diagrams/json/digitP.svg)

### digit
![Digit](examples/diagrams/json/digit.svg)

### hexDigit
![HexDigit](examples/diagrams/json/hexDigit.svg)
